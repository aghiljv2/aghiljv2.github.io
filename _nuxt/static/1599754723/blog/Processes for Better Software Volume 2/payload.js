__NUXT_JSONP__("/blog/Processes for Better Software Volume 2", (function(a,b,c,d,e,f,g,h,i,j,k){return {data:[{post:{name:f,titleImage:k,briefdesc:j,toc:[],body:{type:"root",children:[{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"\n  Every engineer\u002Fdeveloper has the right to do their work the right way, not\n  necessarily the easy way.\n"}]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"\n  There are a lot of reasons a software fails to serve its intended purpose. But\n  most of them could be avoided if we implement the so called good practices\n  into the software development life-cycle.\n"}]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:a,tag:g,props:{},children:[{type:b,value:"1. Accurate understanding of end-user needs"}]},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:h,props:{style:i,src:"\u002Fimg\u002Fblog\u002F020920\u002FuserNeeds.jpg",alt:"Accurate understanding of end-user needs"},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"\n  No matter you are making software as a product or for a client, you have to\n  have a clear understanding of the end-user needs. Significant man hours have\n  gone to waste and so have many applications built during it just by failing to\n  understand the same. The end-user or client needs cannot usually be determined\n  by one single meeting. It requires good research and understanding the problem\n  statement first-hand. Then and only then we could try and solve the problem\n  more efficiently.\n"}]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:a,tag:g,props:{},children:[{type:b,value:"2. Taking it slow"}]},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:h,props:{style:i,src:"\u002Fimg\u002Fblog\u002F020920\u002Fslow.jpg",alt:"Taking it slow"},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"\n  “Slow and steady wins the race”. Sure, you could actually make the software\n  development process much faster, but usually at the expense of compromising\n  some vital steps. The applications developed skipping these “non-essential\n  steps” might sooner or later become a big problem. It might be true that you\n  could save the time and resources while building it in the first place. But,\n  when (not if) it comes back with bugs, it will cost you more of both.\n"}]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:a,tag:g,props:{},children:[{type:b,value:"3. Refactor"}]},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:h,props:{style:i,src:"\u002Fimg\u002Fblog\u002F020920\u002Frefactor.jpg",alt:"Refactor"},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"\n  There is usually the need to upgrade and maintain a software as time goes on.\n  Whenever you see the need and have the chance do not hesitate to refactor the\n  code. Refactoring will usually help create a code base with increased\n  readability, smooth execution, less bugs and higher performance.\n"}]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:a,tag:g,props:{},children:[{type:b,value:"4. Make code correct first and fast second"}]},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:h,props:{style:i,src:"\u002Fimg\u002Fblog\u002F020920\u002FcorrectFirst.jpg",alt:"Make code correct first and fast second"},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"\n  Your primary focus should always be achieving the desired functionality. It\n  doesn’t matter how better the design or how fast the response is, if it cannot\n  produce appropriate output, that software is useless and a liability.\n"}]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:a,tag:g,props:{},children:[{type:b,value:"5. Using version control"}]},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:h,props:{style:i,src:"\u002Fimg\u002Fblog\u002F020920\u002FversionControl.jpg",alt:"Using version control"},children:[]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"\n  Do not wait for the software to grow beyond a certain size to incorporate\n  version control applications such as GitHub or bitbucket. It is always a good\n  practice to create repositories from day one. Create branches and maintain it\n  responsibly. My method is to always keep at least three branches even for a\n  single engineer. One for release, one with the latest stable version and one\n  for the working copy. Any method would be good as long as it helps to keep a\n  backup as well as a smooth workflow.\n"}]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:b,value:c},{type:a,tag:e,props:{},children:[{type:b,value:"\n  Disclaimer : The views and opinions expressed in the text belong solely to the\n  author, and not necessarily to the author's employer, organisation, committee\n  or other group or individual.\n"}]},{type:b,value:c},{type:a,tag:d,props:{},children:[]},{type:a,tag:d,props:{},children:[]}]},dir:"\u002Fblogs",path:"\u002Fblogs\u002FProcesses for Better Software Volume 2",extension:".md",slug:f,createdAt:"2020-09-10T14:48:48.884Z",updatedAt:"2020-09-10T15:59:29.339Z"},blogItem:{_id:"5f5372125e0cb9fc4aa04bea",name:f,titleImage:k,briefdesc:j,content:"\u003Cbr \u002F\u003E \u003Cp\u003E   Every engineer\u002Fdeveloper has the right to do their work the right way, not   necessarily the easy way. \u003C\u002Fp\u003E \u003Cbr \u002F\u003E \u003Cp\u003E   There are a lot of reasons a software fails to serve its intended purpose. But   most of them could be avoided if we implement the so called good practices   into the software development life-cycle. \u003C\u002Fp\u003E \u003Cbr \u002F\u003E \u003Cbr \u002F\u003E\u003Cb\u003E1. Accurate understanding of end-user needs\u003C\u002Fb\u003E\u003Cbr \u002F\u003E \u003Cbr \u002F\u003E \u003Cimg   style=\"width: 100%\"   src=\"\u002Fimg\u002Fblog\u002F020920\u002FuserNeeds.jpg\"   alt=\"Accurate understanding of end-user needs\" \u002F\u003E \u003Cbr \u002F\u003E\u003Cbr \u002F\u003E \u003Cp\u003E   No matter you are making software as a product or for a client, you have to   have a clear understanding of the end-user needs. Significant man hours have   gone to waste and so have many applications built during it just by failing to   understand the same. The end-user or client needs cannot usually be determined   by one single meeting. It requires good research and understanding the problem   statement first-hand. Then and only then we could try and solve the problem   more efficiently. \u003C\u002Fp\u003E \u003Cbr \u002F\u003E \u003Cbr \u002F\u003E\u003Cb\u003E2. Taking it slow\u003C\u002Fb\u003E\u003Cbr \u002F\u003E \u003Cbr \u002F\u003E \u003Cimg style=\"width: 100%\" src=\"\u002Fimg\u002Fblog\u002F020920\u002Fslow.jpg\" alt=\"Taking it slow\" \u002F\u003E \u003Cbr \u002F\u003E\u003Cbr \u002F\u003E \u003Cp\u003E   “Slow and steady wins the race”. Sure, you could actually make the software   development process much faster, but usually at the expense of compromising   some vital steps. The applications developed skipping these “non-essential   steps” might sooner or later become a big problem. It might be true that you   could save the time and resources while building it in the first place. But,   when (not if) it comes back with bugs, it will cost you more of both. \u003C\u002Fp\u003E \u003Cbr \u002F\u003E \u003Cbr \u002F\u003E\u003Cb\u003E3. Refactor\u003C\u002Fb\u003E\u003Cbr \u002F\u003E \u003Cbr \u002F\u003E \u003Cimg style=\"width: 100%\" src=\"\u002Fimg\u002Fblog\u002F020920\u002Frefactor.jpg\" alt=\"Refactor\" \u002F\u003E \u003Cbr \u002F\u003E\u003Cbr \u002F\u003E \u003Cp\u003E   There is usually the need to upgrade and maintain a software as time goes on.   Whenever you see the need and have the chance do not hesitate to refactor the   code. Refactoring will usually help create a code base with increased   readability, smooth execution, less bugs and higher performance. \u003C\u002Fp\u003E \u003Cbr \u002F\u003E \u003Cbr \u002F\u003E\u003Cb\u003E4. Make code correct first and fast second\u003C\u002Fb\u003E\u003Cbr \u002F\u003E \u003Cbr \u002F\u003E \u003Cimg   style=\"width: 100%\"   src=\"\u002Fimg\u002Fblog\u002F020920\u002FcorrectFirst.jpg\"   alt=\"Make code correct first and fast second\" \u002F\u003E \u003Cbr \u002F\u003E\u003Cbr \u002F\u003E \u003Cp\u003E   Your primary focus should always be achieving the desired functionality. It   doesn’t matter how better the design or how fast the response is, if it cannot   produce appropriate output, that software is useless and a liability. \u003C\u002Fp\u003E \u003Cbr \u002F\u003E \u003Cbr \u002F\u003E\u003Cb\u003E5. Using version control\u003C\u002Fb\u003E\u003Cbr \u002F\u003E \u003Cbr \u002F\u003E \u003Cimg   style=\"width: 100%\"   src=\"\u002Fimg\u002Fblog\u002F020920\u002FversionControl.jpg\"   alt=\"Using version control\" \u002F\u003E \u003Cbr \u002F\u003E\u003Cbr \u002F\u003E \u003Cp\u003E   Do not wait for the software to grow beyond a certain size to incorporate   version control applications such as GitHub or bitbucket. It is always a good   practice to create repositories from day one. Create branches and maintain it   responsibly. My method is to always keep at least three branches even for a   single engineer. One for release, one with the latest stable version and one   for the working copy. Any method would be good as long as it helps to keep a   backup as well as a smooth workflow. \u003C\u002Fp\u003E \u003Cbr \u002F\u003E \u003Cp\u003E   Disclaimer : The views and opinions expressed in the text belong solely to the   author, and not necessarily to the author's employer, organisation, committee   or other group or individual. \u003C\u002Fp\u003E \u003Cbr \u002F\u003E\u003Cbr \u002F\u003E"},title:f,description:j,ogImage:"\u002Fimg\u002Fblog\u002F020920\u002Fprocess2Title.jpg",params:{slug:f}}],fetch:[],mutations:[]}}("element","text","\n","br","p","Processes for Better Software Volume 2","b","img","width: 100%","Best practices for software engineers continued","020920\u002Fprocess2Title")));